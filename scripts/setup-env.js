import { readFile, writeFile, readdir } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { spawn } from 'child_process';

const TARGET_CANISTER_NAMES = ['ii-integration', 'frontend', 'backend'];

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = path.resolve(__dirname, '..');
console.log('Root directory:', rootDir);

const mkcertPath = path.join(rootDir, '.mkcert');
const frontendEnvFilePath = path.join(
  rootDir,
  'src',
  'frontend',
  'constants',
  'env.generated.ts',
);
const iiIntegrationEnvFilePath = path.join(
  rootDir,
  'src',
  'ii-integration',
  'env.generated.ts',
);

const dfxNetwork = process.env.DFX_NETWORK;
if (!dfxNetwork) {
  throw new Error('DFX_NETWORK is not set');
}
console.log('DFX Network:', dfxNetwork);

const getCanisterIdsPath = () => {
  switch (dfxNetwork) {
    case 'local':
      return path.join(rootDir, '.dfx', 'local', 'canister_ids.json');
    case 'playground':
      return path.join(rootDir, '.dfx', 'playground', 'canister_ids.json');
    case 'ic':
      return path.join(rootDir, 'canister_ids.json');
    default:
      throw new Error(`Unsupported network: ${dfxNetwork}`);
  }
};

const readAndParseCanisterIds = async (filePath) => {
  if (!existsSync(filePath)) {
    return undefined;
  }

  const data = await readFile(filePath, 'utf8');

  return JSON.parse(data);
};

const normarizeCanisterIds = (canisterIds) => {
  const normalized = {};

  Object.entries(canisterIds).forEach(([key, value]) => {
    if (!key.startsWith('_')) {
      normalized[key] = Object.values(value)[0];
    }
  });

  return normalized;
};

const spawnProcess = (command, args) => {
  return new Promise((resolve, reject) => {
    const process = spawn(command, args);

    process.on('close', (status) => {
      if (status === 0) {
        resolve();
      } else {
        reject(new Error(`Command failed with status ${status}`));
      }
    });

    process.on('error', (error) => {
      reject(error);
    });
  });
};

const createCanisters = async () => {
  try {
    const code = await spawnProcess('dfx', [
      'canister',
      'create',
      '--all',
      '--network',
      dfxNetwork,
    ]);

    return code === 0;
  } catch (error) {
    console.error('Error creating canisters:', error);
    return false;
  }
};

const getLocalIPAddress = async () => {
  if (!existsSync(mkcertPath)) {
    throw new Error(
      'Mkcert path does not exist. See https://github.com/higayasuo/expo-icp/blob/main/docs/setup.md#mkcert-installation https://github.com/higayasuo/expo-icp/blob/main/docs/setup.md#setting-up-static-ip-address and https://github.com/higayasuo/expo-icp/blob/main/docs/setup.md#creating-server-certificate',
    );
  }

  const files = await readdir(mkcertPath);
  const pemFile = files.find((file) => file.endsWith('-key.pem'));

  if (!pemFile) {
    throw new Error(
      'No pem file found in mkcert path. See https://github.com/higayasuo/expo-icp/blob/main/docs/setup.md#mkcert-installation https://github.com/higayasuo/expo-icp/blob/main/docs/setup.md#setting-up-static-ip-address and https://github.com/higayasuo/expo-icp/blob/main/docs/setup.md#creating-server-certificate',
    );
  }

  return path.basename(pemFile, '-key.pem');
};

const generateEnvFile = async (normalizedCanisterIds, localIPAddress) => {
  const content = `// This file is auto-generated. Do not edit this file.
// Generated from scripts/setup-env.js

export const LOCAL_IP_ADDRESS = '${localIPAddress}';
export const DFX_NETWORK = '${dfxNetwork}';
export const CANISTER_ID_INTERNET_IDENTITY = 'rdmx6-jaaaa-aaaaa-aaadq-cai';
export const CANISTER_ID_II_INTEGRATION = '${normalizedCanisterIds['ii-integration']}';
export const CANISTER_ID_FRONTEND = '${normalizedCanisterIds.frontend}';
export const CANISTER_ID_BACKEND = '${normalizedCanisterIds.backend}';
`;
  console.log('Env file content:', content);

  await writeFile(frontendEnvFilePath, content);
  await writeFile(iiIntegrationEnvFilePath, content);

  // const envFilePath = path.join(rootDir, '.env');
  // const envFileContent = `
  // `;
  // await writeFile(envFilePath, envFileContent);
};

const setupCanisterIds = async () => {
  const canisterIdsPath = getCanisterIdsPath();
  console.log('Canister IDs path:', canisterIdsPath);

  const canisterIds = await readAndParseCanisterIds(canisterIdsPath);
  console.log('Canister IDs:', canisterIds);

  if (
    canisterIds &&
    canisterIds['ii-integration'] &&
    canisterIds.frontend &&
    canisterIds.backend
  ) {
    return normarizeCanisterIds(canisterIds);
  }

  await createCanisters();

  const canisterIds2 = await readAndParseCanisterIds(canisterIdsPath);
  console.log('2nd Canister IDs:', canisterIds2);

  return normarizeCanisterIds(canisterIds2);
};

const main = async () => {
  try {
    const normalizedCanisterIds = await setupCanisterIds();
    console.log('Normalized Canister Ids:', normalizedCanisterIds);

    const localIPAddress = await getLocalIPAddress();
    console.log('Local IP Address:', localIPAddress);

    await generateEnvFile(normalizedCanisterIds, localIPAddress);
  } catch (error) {
    console.log('Error:', error);
    process.exit(1);
  }
};

main();
